# Automation Management Rules for TappHA

## MANDATORY: Home Assistant Automation API

**ALWAYS** implement safe and compliant automation management for TappHA's Home Assistant integration.

### Home Assistant Automation API Integration

#### Core API Patterns
- **ALWAYS** use Home Assistant's official automation API endpoints
- **ALWAYS** implement proper authentication with long-lived access tokens
- **ALWAYS** validate automation syntax before deployment
- **ALWAYS** implement backup snapshots before modifying automations
- **ALWAYS** use proper error handling for API failures
- **ALWAYS** implement rollback mechanisms for failed automation changes

#### Automation Lifecycle Management
- **ALWAYS** track automation lifecycle states (draft, pending, active, disabled)
- **ALWAYS** implement approval workflows before applying automation changes
- **ALWAYS** maintain version history for all automation modifications
- **ALWAYS** implement automated testing for automation syntax validation
- **ALWAYS** provide rollback capabilities for all automation changes

### Safety and Compliance Mechanisms

#### User Consent and Approval
- **ALWAYS** require explicit user consent for automation modifications
- **ALWAYS** implement multi-level approval workflows for significant changes
- **ALWAYS** provide clear explanations of automation changes before applying
- **ALWAYS** allow users to disable automation features completely
- **ALWAYS** implement granular control preferences for automation operations

#### Emergency Stop System
- **ALWAYS** implement instant disable capability for all automation features
- **ALWAYS** provide immediate rollback for automation changes
- **ALWAYS** maintain backup snapshots before any automation modifications
- **ALWAYS** implement comprehensive logging for all automation operations
- **ALWAYS** provide emergency contact procedures for critical issues

#### Audit Trail Requirements
- **ALWAYS** log all automation creation, modification, and deletion events
- **ALWAYS** record user approval decisions and timestamps
- **ALWAYS** maintain immutable audit logs with cryptographic signatures
- **ALWAYS** provide audit trail export for compliance reporting
- **ALWAYS** track automation performance metrics and usage patterns

### Automation Code Patterns

#### Service Layer Implementation
```java
@Service
@Transactional
public class AutomationManagementService {
    
    private final HomeAssistantAPIService haService;
    private final BackupService backupService;
    private final AuditTrailService auditService;
    private final ApprovalWorkflowService approvalService;
    
    public AutomationResponse createAutomation(AutomationRequest request) {
        // ALWAYS validate user consent first
        validateUserConsent(request.getUserId());
        
        // ALWAYS create backup before modification
        backupService.createBackup("pre-automation-creation");
        
        // ALWAYS require approval for new automations
        if (!approvalService.isApproved(request.getUserId(), "automation_creation")) {
            throw new ApprovalRequiredException("User approval required for automation creation");
        }
        
        try {
            // ALWAYS validate automation syntax
            validateAutomationSyntax(request.getAutomationConfig());
            
            // ALWAYS log operation start
            auditService.logAutomationOperationStart(request);
            
            // ALWAYS use Home Assistant API
            AutomationResponse response = haService.createAutomation(request);
            
            // ALWAYS log successful operation
            auditService.logAutomationOperationSuccess(request, response);
            
            return response;
            
        } catch (Exception e) {
            // ALWAYS rollback on failure
            backupService.rollback("pre-automation-creation");
            
            // ALWAYS log operation failure
            auditService.logAutomationOperationFailure(request, e);
            throw new AutomationServiceException("Automation creation failed", e);
        }
    }
    
    public void updateAutomation(String automationId, AutomationUpdateRequest request) {
        // ALWAYS create backup before modification
        backupService.createBackup("pre-automation-update-" + automationId);
        
        // ALWAYS require approval for automation changes
        if (!approvalService.isApproved(request.getUserId(), "automation_modification")) {
            throw new ApprovalRequiredException("User approval required for automation modification");
        }
        
        try {
            // ALWAYS validate updated automation syntax
            validateAutomationSyntax(request.getAutomationConfig());
            
            // ALWAYS log operation start
            auditService.logAutomationOperationStart(request);
            
            // ALWAYS use Home Assistant API
            haService.updateAutomation(automationId, request);
            
            // ALWAYS log successful operation
            auditService.logAutomationOperationSuccess(request);
            
        } catch (Exception e) {
            // ALWAYS rollback on failure
            backupService.rollback("pre-automation-update-" + automationId);
            
            // ALWAYS log operation failure
            auditService.logAutomationOperationFailure(request, e);
            throw new AutomationServiceException("Automation update failed", e);
        }
    }
}
```

#### Frontend Automation Management
```typescript
// ALWAYS implement approval workflow for automation changes
const useAutomationApproval = (userId: string) => {
  const [pendingApprovals, setPendingApprovals] = useState<Approval[]>([]);
  
  const requestApproval = async (operation: string, automationId?: string) => {
    const approval = await showApprovalDialog(operation, automationId);
    if (approval) {
      setPendingApprovals(prev => [...prev, approval]);
      return true;
    }
    return false;
  };
  
  return { pendingApprovals, requestApproval };
};

// ALWAYS provide automation explanation before applying changes
const AutomationManagementComponent: React.FC<AutomationProps> = ({ automation }) => {
  const [showExplanation, setShowExplanation] = useState(false);
  const { requestApproval } = useAutomationApproval(automation.userId);
  
  const handleUpdateAutomation = async (changes: AutomationChanges) => {
    // ALWAYS show explanation before applying
    setShowExplanation(true);
    
    // ALWAYS require approval for changes
    const approved = await requestApproval("automation_modification", automation.id);
    if (approved) {
      await updateAutomation(automation.id, changes);
    }
  };
  
  return (
    <div>
      <h3>Automation Management</h3>
      <div className="automation-details">
        <h4>{automation.name}</h4>
        <p>{automation.description}</p>
        <div className="automation-status">
          Status: {automation.status}
        </div>
      </div>
      
      <button onClick={() => setShowExplanation(true)}>
        Modify Automation
      </button>
      
      {showExplanation && (
        <div className="explanation-panel">
          <h4>Proposed Changes</h4>
          <p>Review the proposed automation changes before applying:</p>
          <AutomationDiffView changes={proposedChanges} />
          <button onClick={() => handleUpdateAutomation(proposedChanges)}>
            Apply Changes
          </button>
          <button onClick={() => setShowExplanation(false)}>
            Cancel
          </button>
        </div>
      )}
    </div>
  );
};
```

### Automation Testing Requirements

#### Unit Testing
- **ALWAYS** test automation syntax validation
- **ALWAYS** test approval workflow implementations
- **ALWAYS** test backup and rollback mechanisms
- **ALWAYS** verify audit trail generation

#### Integration Testing
- **ALWAYS** test automation management with actual Home Assistant instances
- **ALWAYS** validate automation API integration
- **ALWAYS** test emergency stop mechanisms
- **ALWAYS** verify backup and rollback operations

#### Performance Testing
- **ALWAYS** test automation creation/modification response times (<2 seconds)
- **ALWAYS** validate backup and rollback performance (<10 seconds)
- **ALWAYS** test concurrent automation operations
- **ALWAYS** verify audit trail performance (<500ms)

### Automation Configuration Requirements

#### Environment Variables
- **ALWAYS** use environment variables for Home Assistant API credentials
- **ALWAYS** implement proper secrets management for access tokens
- **ALWAYS** use different credentials for development and production
- **ALWAYS** implement credential rotation mechanisms

#### Performance Configuration
- **ALWAYS** set appropriate timeouts for Home Assistant API calls
- **ALWAYS** implement connection pooling for API services
- **ALWAYS** configure proper retry mechanisms
- **ALWAYS** set rate limits for automation operations

### Automation Documentation Requirements
- **ALWAYS** document automation API integration patterns
- **ALWAYS** provide user guides for automation management features
- **ALWAYS** document safety mechanisms and emergency procedures
- **ALWAYS** maintain API documentation for automation services

description: Home Assistant automation management patterns for TappHA with safety and compliance mechanisms
globs: ["**/*.java", "**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"]
alwaysApply: false
---
description:
globs:
alwaysApply: false
---
